<script>
class Node {
 constructor(parent, objDef) {
	const t= this	, d=Node.dom // TODO: should move most of the constructor code to method reset()
	, p=t.parent = (parent || (!Node.root&&t.initRoot()))
	, a= (Array .isArray(objDef ) && objDef ) || Node.MenuItems // (!Node.root&&Node.MenuItems)
	, s= (typeof(objDef) =='string' && objDef)|| objDef?.title ||(t==Node.root&&'Root')//|| (a&&a[0])
	, m=objDef?.menu || a//&&a [1]
	t.objDef = objDef || a
	t.id=(t.createdTime=new Date()).getTime()
	if(parent ){
		if(!p.subtasks)
			parent.subtasks=[]
		parent.subtasks.push(t)	}
	const p2=parent?.elems?.subtasks || parent ?.e || p
	t.elems={ e: d.c('fieldset', p2 ,{classList:'node'})}
	t.elems.eLegend=d.c('legend',t.elems.e,0
		,[t.elems.label=d.c('span',t.elems.e
			,{textContent:t.label=s || 'ttl'
			, contentEditable:true
			, input:e=>t.onChng('label',t.elems.label.textContent)
			})
		//, t.elems.description=d.d( 'description' , t.elems.e )
		//, t.elems.implementation= d.d( 'implementation' , t.elems.e )
		, t.elems.menu=m&& t.createMenu(m,t.elems.e)
		])
	t.elems. subtasks =d.c( 'fieldset' , t.elems.e ,0,d.c('legend',0
		,{textContent:'subtasks'}
		,d.c('button',0,{textContent:'+',onclick:
			e=>t.onChng('createSubtask',t.createChild({title:prompt('please enter name of new subTask','Task: '+new Date())}))
		})))
	t.elems.label.addEventListener('input',
		e=>t.onChng('label',t.elems.label.textContent)
	
	)
 } // constructor

reset(parent, objDef) {
	const t= this	, d=Node.dom 
	, p=t.parent = (parent || (!Node.root&&t.initRoot()))
	, a= (Array .isArray(objDef ) && objDef ) || Node.MenuItems // (!Node.root&&Node.MenuItems)
	, s= (typeof(objDef) =='string' && objDef)|| objDef?.title ||(t==Node.root&&'Root')//|| (a&&a[0])
	, m=objDef?.menu || a//&&a [1]
	t.objDef = objDef || a
	t.id=(t.createdTime=new Date()).getTime()
	if(parent ){
		if(!p.subtasks)
			parent.subtasks=[]
		parent.subtasks.push(t)	}
	const p2=parent?.elems?.subtasks || parent ?.e || p
	t.elems={ e: d.c('fieldset', p2 ,{classList:'node'})}
	t.elems.eLegend=d.c('legend',t.elems.e,0
		,[t.elems.label=d.c('span',t.elems.e
			,{textContent:t.label=s || 'ttl'
			, contentEditable:true
			, input:e=>t.onChng('label',t.elems.label.textContent)
			})
		//, t.elems.description=d.d( 'description' , t.elems.e )
		//, t.elems.implementation= d.d( 'implementation' , t.elems.e )
		, t.elems.menu=m&& t.createMenu(m,t.elems.e)
		])
	t.elems. subtasks =d.c( 'fieldset' , t.elems.e ,0,d.c('legend',0
		,{textContent:'subtasks'}
		,d.c('button',0,{textContent:'+',onclick:
			e=>t.onChng('createSubtask',t.createChild({title:prompt('please enter name of new subTask','Task: '+new Date())}))
		})))
	t.elems.label.addEventListener('input',
		e=>t.onChng('label',t.elems.label.textContent)
	
	)
	
 } // reset

 initRoot(){
	const t=Node.root=this
	,b=document.body
	
	return b
	}

 onChng(propName,propVal){
	//if(propName type isnt const)
	this[propName]=propVal
	console.log('Node.onChng',this,propName,propVal)
	}

 toJsonString(){
	const j={},t=this
	Node.JsonPropNames.forEach(a=>j[a[0]]=t[a[0]])
	return JSON.stringify(j)}

 createMenu(menuItems,parent){
	//4 cases: case1: menuItems is only a string
	//	case2: array of string items //if(typeof menuItems == 'string' )
	//	case3: array of arrays	,recursively call createMenu on each sub-array
	//	case4: array of 2 items ,1string & 1func ==> a button with a label and a callback
	const t=this
	,d=Node.dom
	,p=parent?.elems?.menu || parent?.e || parent
	,n=menuItems?.length
	,label=menuItems[0]
	if(n==2 && typeof menuItems[1]=='function')
		return d.createButton(label,evt=>(menuItems[1])(t,evt),p)
	const hde=d.d({textContent:label,style:{'font-size':6}},p)
	,ul=n>1 && d.c('ul',hde)
	for(let i=1;i<n;i++){
		const item=menuItems[i];
		if(Array.isArray(item))
			t.createMenu(item,ul)
		else if(typeof(item)=='string')
			d.c('li',ul,{textContent:item})
		else{d.c(item.elemName|| item.n || 'li',ul,item)
			/*
			hde.addEventListener("toggle", (event) => {
				if (hde.open) {
					// the html-details-element(hde) was toggled open 
				} else {
					// the html-details-element(hde) was toggled closed 
				}
			})*/
		}
	}
	return hde;
 } // createMenu

 createChild(objDef) {
	const t=this,n= new Node(t, objDef)// ,parent = this.div
	//if(!t.subtasks)t.subtasks=[]t.subtasks.push(n)
 return}

 createDesc(){
	const t=this,d=Node.dom, // TODO: implementation
	} // createDesc

 static dom = {
  c: function createElement(elemName, parent, atrb, chldrn,chldr2) {
	const e = elemName?.nodeType ? elemName
		: document.createElement(elemName), d = Node.dom
	if (atrb) d.atrb(e, atrb)
	if (chldrn) chldrn?.forEach
		? chldrn.forEach(c => d.c(c?.n || c, e, c?.atrb, c?.chldrn))
		: e.appendChild(chldrn?.nodeType ? chldrn : document.createTextNode(chldrn))
	if (chldr2) chldr2?.forEach
		? chldr2.forEach(c => d.c(c?.n || c, e, c?.atrb, c?.chldrn))
		: e.appendChild(chldr2?.nodeType ? chldr2 : document.createTextNode(chldr2))
	if (parent?.appendChild) parent.appendChild(e)
	return e
	}//Node.dom.c

 , atrb: function setAttributesAndProps(elem, atrbs) {
 /*sets attributes on element-elem from properties(name/value) of object parameter-atrbs,

 property-names that have special behaviour(classList, style, on), 
 
 classList is either a string or an array 
 (currently only string is implemented, adds a css class name to the elem)

 "style" is expected to be an object 
 and the properties are css properties set on elem.style

 "on" is expected to be an object 
 and the properties (values)are event-handlers ,
 set using elem.addEventListener 
 where the property name is the name of the event 
 and the property value is expected to be a function

 */
	Object.keys(atrbs).forEach(k => k == 'classList'
		? elem[k].add(atrbs[k])
		:k=='on'? Object.keys(atrbs.on).forEach(evtNm => elem.addEventListener(evtNm, atrbs.on[evtNm] ))
		: k != 'style' ? (elem[k] = atrbs[k])
		: Object.keys(atrbs[k]).forEach(j => elem.style[j] = atrbs[k][j])) }

, createButton: (label, onClick, parent) => Node.dom.c(
	'button', parent, { textContent: label, onclick: onClick })

,fs:(title,parent,chldrn)=>Node.dom.c('fieldset',parent,0
	,Node.dom.c('legend',0,{textContent:title}),chldrn)

,d:(title_orSummaryAttribs,parent,chldrn,hdeAtrbs)=>Node.dom.c('details',parent,hdeAtrbs
	,Node.dom.c('summary',0
	,typeof(title_orSummaryAttribs)=='string'?{textContent:title_orSummaryAttribs}:title_orSummaryAttribs)
	,chldrn)
 } // static dom

 static JsonPropNames=[['id','const']
	,['label','string']
	,['subtasks','ref:id']
	,['descriptions','[string]']
	,['Appearance','[string]']
	,['modules','[string]']]
 static MenuItems=['Menu',
	['Clipboard menu',
		'Duplicate'
		,'Cut'
		,'Paste as subtasks'
		,['Multi-select',
			'Add to multi-select'
			,'Remove from multi-select']
		,['Position',
			'Reset'
			,'Set'
			,'Drag']
		,['Json',
			'toJsonString'
			,'New subtasks from json'
			,'Textarea']
	 ] // Clipboard
	,['New Subtask',node=>node.createChild({title:new Date()})]
	,['Appearance menu',
		['Border',
			'Background color'
			,'Stroke color'
			,'Stroke width'
			,'Corners radius']
		,['Text',
			'Color'
			,'Font'
			,'Size']
	 ] // Appearance
	,['Description menu',
		['Add description text',node=>node.newDesc()]
		,'Set description category'
		,'Add link'
		,'Set desc location']
	,['Implementation modules menu',
		'Add source code module'
		,'Delete module'
		,'Set programming language of module'
		,'Set tech stack']
 ] // MenuItems

loadFromJson(js){
	//TODO: set this
	const t=this,j=JSON.parse(js)
	Object.keys(j).forEach(k=>t[k]=
		k!='subtasks'?j[k]
		:Array.isArray(j[k])?j[k].map(i=>i // TODO: need cache ,name/value pairs items are: id and task/node
			)
		:j[k]
		)
	}

static root=0
static onLoad=onload=()=>new Node()
static storage={
save:function(){localStorage.rootTask=Node.root.toJsonString()}
load:function(){
	try{const s=localStorage.rootTask
	,j=JSON.parse(s)
	Node.root.reset().loadFromJson(j);
	}catch(ex){}}
}//static storage

} // class Node

</script>
<style>
	body , svg , canvas {padding:5px;
		linear-gradient(160deg
			,rgba(2,0,36,0.6979166666666667) 0%
			,rgba(9,9,121,0.39539565826330536) 35%
			,rgba(0,212,255,0.43461134453781514) 100%);
		touch-action: all
		}

	details,summary,fieldset{
		border:1px solid blue;
		border-radius:5px;
		padding:5px;
		margin:2px;
		background-color: #a0d3ff57;
		/*float: left;*/
		}
details{display:inline}

	summary,legend{
		display: inline;
		background-color: #f5f589b8 ;
		margin-top: 0px;
		margin-left: 0px;
	}
.node{border:3px solid black;margin: 30px;}

</style>
